<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - app/scripts/services/profileOutline.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>app/scripts/services/profileOutline.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">382</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">65.99</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.05</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;
define([
   &#039;angular&#039;
  ,&#039;threejs&#039;  
  ,&#039;lodash&#039;
  ,&#039;models/m3dProfile&#039;
  ,&#039;models/m3dProfilePoint&#039;
  ,&#039;models/footprint&#039;
  ,&#039;models/rectFootprint&#039;
  ,&#039;models/polyFootprint&#039;
  ,&#039;models/gemeindeFootprint&#039;
  ,&#039;util/ProfileUtil&#039;
  ],
  function(angular, THREE, _, Profile, ProfilePoint, Footprint, RectFootprint, PolyFootprint, GemeindeFootprint, ProfileUtil){

    var extrudeSettings = { 
      amount: localStorage.getItem(&#039;thickness&#039;) || 2, 
      bevelEnabled: false, 
      bevelSegments: 2, 
      steps: 2, 
      bevelSize: 1, 
      bevelThickness: 1 
    };

    var $log, $rootScope;

    /**
     * ProfileOutlineService
     * Service to load and save files from/to file
     * @class
     * @name m3d.services.ProfileOutlineService 
     * @constructor
     * @namespace
     */
    var ProfileOutlineService = function(log, rootScope){
      $log = log;
      $rootScope = rootScope;
    };

    /**
    * Create a Profile from a mesh
    * @param {THREE.Mesh} mesh the mesh
    */
    ProfileOutlineService.prototype.createFromMesh = function(mesh){
      // create ProfilePoints from vertices on top
      var topVertices = this.getTopVertices(mesh.geometry.vertices);
      var profilePoints = [];
      _.forEach(topVertices, angular.bind(this, function(vertex){
        profilePoints.push(new ProfilePoint({topVertex: vertex}));
      }));
      // sort by lat and lng
      profilePoints = _.sortByAll(profilePoints, [&#039;lat&#039;, &#039;lng&#039;]);

      // assume rectangular footprint
      var footprint = new RectFootprint();
      footprint.setProfilePoints(profilePoints);

      var profile = new Profile({
        mesh: mesh,
        profilePoints: profilePoints,
        footprint: footprint
      });
      return profile;
    };

    ProfileOutlineService.prototype.createProfile = function(footprint){
      var mesh = null;
      var profilePoints = footprint.getProfilePoints();
      if (footprint instanceof PolyFootprint || footprint instanceof GemeindeFootprint)
        mesh = this.createPolyMesh(profilePoints);
      // assume footprint is rectangular
      else if (footprint instanceof RectFootprint)
        mesh = this.createRectMesh(profilePoints);
      var profile = new Profile({
        footprint: footprint,
        mesh: mesh,
        profilePoints: profilePoints,        
      });
      return profile;
    };

    ProfileOutlineService.prototype.createRectMesh = function(profilePoints){      
      var maxLng = _.max(_.pluck(profilePoints, &#039;lng&#039;));
      var minLng = _.min(_.pluck(profilePoints, &#039;lng&#039;));
      var maxLat = _.max(_.pluck(profilePoints, &#039;lat&#039;));
      var minLat = _.min(_.pluck(profilePoints, &#039;lat&#039;));
      var maxElv = _.max(_.pluck(profilePoints, &#039;elv&#039;));
      var minElv = _.min(_.pluck(profilePoints, &#039;elv&#039;));

      var height = localStorage.getItem(&#039;thickness&#039;) || 1;
      var depth = maxLat - minLat;
      var width = maxLng - minLng;

      // Faktor zur Normalisierung auf 50 (längste Seite)
      var factor = 50/Math.max(depth, width);      
      depth = depth * factor;
      width = width * factor;

      var segmentsX =  Math.sqrt(profilePoints.length) - 1;
      var segmentsY =  Math.sqrt(profilePoints.length) - 1;

      var geometry = new THREE.BoxGeometry(height, depth, width, 1, segmentsX, segmentsY);
      var material = new THREE.MeshPhongMaterial({color: 0x00ff00, dynamic: true });
      var mesh = new THREE.Mesh(geometry, material);
      this.mesh = mesh;
      mesh.name = this.name;
      mesh.geometry.dynamic = true;

      var rotationZ = new THREE.Matrix4().makeRotationZ( - Math.PI/2 );
      var rotationX = new THREE.Matrix4().makeRotationX( Math.PI );
      mesh.updateMatrix();
      mesh.geometry.applyMatrix(mesh.matrix);
      mesh.geometry.applyMatrix(rotationZ);
      mesh.geometry.applyMatrix(rotationX);
      mesh.matrix.identity();

      // Faktor zur Normalisierung der Höhe im Verhältnis zur Seite
      var widthInMeters = ProfileUtil.getDistanceZ(profilePoints);
      var scaleFactor = widthInMeters/width;

      // Vertices verschieben und mit Profilpunkten verbinden
      var diff = 0;
      _.forEach(profilePoints, function(point, i){
        diff = (point.elv - minElv)/scaleFactor;
        var bottomIndex = ProfileUtil.getBottomIndex(i, mesh.geometry.vertices);
        var topVertex = mesh.geometry.vertices[i];
        var bottomVertex = mesh.geometry.vertices[bottomIndex];
        topVertex.y += diff; 
        bottomVertex.y += diff;        
        point.topVertex = topVertex;
        point.bottomVertex = bottomVertex;
      }, this);

      mesh.geometry.computeFaceNormals();
      mesh.geometry.computeVertexNormals();
      return mesh;
    };

    ProfileOutlineService.prototype.createPolyMesh = function(coordinates){
      $log.debug(&#039;creating outline for &#039; + coordinates.length + &#039; coordinates&#039;);            

      var maxLat = _.max(coordinates, &#039;lat&#039;).lat;
      var maxLng = _.max(coordinates, &#039;lng&#039;).lng;
      var minLat = _.min(coordinates, &#039;lat&#039;).lat;
      var minLng = _.min(coordinates, &#039;lng&#039;).lng;
      var depth = maxLat - minLat;
      var width = maxLng - minLng;
      var factor = 50/Math.max(depth, width);      

      // Schritt 1: Shape aus Einzelpunkten konstruieren
      var shape = this.createShape(coordinates, factor);

      // Schritt 2: Aus 2D-Shape eine 3D-Geometrie erstellen
      var posX, posY=0;
      posX = (maxLng - minLng)*factor/2;
      posY = (maxLat - minLat)*-factor/2;        
      var extrudedMesh = this.extrude(shape, extrudeSettings, posX, 0, posY);

      // Schritt 3: Die 3D-Geometrie regelmässig rastern und die Rasterpunkte ermitteln (ohne Randpunkte)
      var rasterResult = this.rasterize(extrudedMesh);
      var rasterizedMesh = rasterResult.mesh;
      var rasterVertices = rasterResult.vertices;

      // Schritt 4: Die ermittelten Rasterpunkte durch die Punkte auf dem Shaperands ergänzen
      //var rasterPoints = this.calculateRasterPoints(rasterVertices, shape);

      // Schritt 5: Die Komplette Liste an Rasterpunkten zurückrechnen  in Koordinaten (ProfilePoints)
      //var profilePoints = this.calculateProfilePoints(rasterPoints);

      // Mesh zurückgeben
      return rasterizedMesh;
    };

    /**
    * Create Shape f
    * @param {m3d.models.ProfilePoint} coordinates list of coordinates to process
    * @returns {THREE.Shape} Shape representing the coordinates as a polygon
    */
    ProfileOutlineService.prototype.createShape = function(coordinates, scale){
      var maxLat = _.max(coordinates, &#039;lat&#039;).lat;
      var maxLng = _.max(coordinates, &#039;lng&#039;).lng;
      var minLat = _.min(coordinates, &#039;lat&#039;).lat;
      var minLng = _.min(coordinates, &#039;lng&#039;).lng;

      var shape = new THREE.Shape();
      _.forEach(coordinates, function(coordinate, i){
        var x = (coordinate.lat - maxLat) * scale;
        var y = (coordinate.lng - maxLng) * scale;
        shape.moveTo(x, y);
      });
      return shape;
    };

    /**
    * Calculates all raster points for a rasterized, but irregular polygon
    * @param {THREE.Mesh} mesh the rasterized mesh used to display the profile which contains all the vertices (but more than actually needed)
    * @param {THREE.Mesh} extrudedMesh the un-rasterized mesh 
    * @param {THREE.Shape} shape the shape used for extrusion
    */ 
    ProfileOutlineService.prototype.calculateRasterPoints = function(rasterizedMesh, extrudedMesh, shape){
      var rasterPoints = [];
      // Schritt 1: Alle Punkte auf dem Polygonrand gehören dazu
      var actions = _.filter(shape.actions, {&#039;action&#039;: &#039;moveTo&#039;});
      _.forEach(actions, function(action, n){
        var x = action.args[0];
        var y = action.args[1];
        //rasterPoints.push({x: x, y: y});
      });

      var isInExtrudedMesh = function(vertex){
        var found = false;
        for (var i=0; i&lt;extrudedMesh.geometry.vertices.length &amp;&amp; !found; i++){
          var v = extrudedMesh.geometry.vertices[i];
          if (v.x == vertex.x &amp;&amp; v.y == vertex.y &amp;&amp; v.z == vertex.z)
            found = true;
        }
        return found;
      };
      // Schritt 2: Alle Punkte des gerasterten Meshes, welche nicht auch im extrudierten Mesh vorkommen, gehören dazu
      rasterizedMesh.geometry.vertices.forEach(function(vertex){
        var inExtrudedMesh = isInExtrudedMesh(vertex);
        if (!inExtrudedMesh)
          rasterPoints.push({x: vertex.x, y: vertex.y});
      });

      return rasterPoints;
    };

    ProfileOutlineService.prototype.calculateProfilePoints = function(rasterPoints){

    };

    ProfileOutlineService.prototype.extrude = function(shape, extrudeSettings, x, y, z){
      var flatGeometry = new THREE.ShapeGeometry(shape);
      var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial( { color: 0x00ff00, ambient: 0x00ff00 } ));

      mesh.geometry.dynamic = true;

      var rotationX = new THREE.Matrix4().makeRotationX( Math.PI/2 );
      var rotationY = new THREE.Matrix4().makeRotationY( Math.PI/2 );

      mesh.updateMatrix();
      mesh.geometry.applyMatrix(mesh.matrix);
      mesh.geometry.applyMatrix(rotationX);
      mesh.geometry.applyMatrix(rotationY);
      mesh.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(x,y,z));
      mesh.matrix.identity();

      return mesh;
    };  

    ProfileOutlineService.prototype.rasterize = function(extrudedMesh){
      var maxX = _.max(extrudedMesh.geometry.vertices, &#039;x&#039;).x;
      var minX = _.min(extrudedMesh.geometry.vertices, &#039;x&#039;).x;
      var maxY = _.max(extrudedMesh.geometry.vertices, &#039;y&#039;).y;
      var minY = _.min(extrudedMesh.geometry.vertices, &#039;y&#039;).y;        
      var maxZ = _.max(extrudedMesh.geometry.vertices, &#039;z&#039;).z;
      var minZ = _.min(extrudedMesh.geometry.vertices, &#039;z&#039;).z;

      var boxWidth = maxX - minX;
      var boxHeight = (maxY - minY)/2;
      var boxDepth = maxZ - minZ;

      // Rasterbox zum Rastern
      var boxGeometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth, 10, 1, 10);        
      var topVertices = this.getTopVertices(boxGeometry.vertices);

      var material = new THREE.MeshPhongMaterial({color: 0x00ff00, dynamic: true, wireframe: false });
      //return new THREE.Mesh(boxGeometry, material);

      var csgBox = new THREE.ThreeBSP(boxGeometry);
      var csgProfile = new THREE.ThreeBSP(extrudedMesh);
      var csgRasterized = csgBox.intersect(csgProfile);
      var geometry = csgRasterized.toGeometry();
      geometry.mergeVertices();

      // relevante Rasterpunkte ermitteln, für die Höhendaten ermittelt werden sollen
      // Diese ergeben sich aus denjenigen Vertices auf der Oberseite des Polygons, welche auch in der Rasterbox enthalten sind
      var topPolygonVertices = this.getCommonVertices(geometry.vertices, topVertices);
      
      var rasterizedMesh = new THREE.Mesh(geometry, material);
      return {
        mesh: rasterizedMesh,
        vertices: topPolygonVertices
      };
    };

    /**
    * Only for rectangular Get the index on the bottom for a vertex on top
    * @param {THREE.Vector3} vertices of arbitrary geometry
    * @return {THREE.Vector3} the vertices on top
    */
    ProfileOutlineService.prototype.getTopVertices = function(vertices){
      var topVertices = [];
      _.forEach(vertices, function(vertex, n){     
        var pair = _.filter(vertices, {&#039;x&#039;: vertex.x, &#039;z&#039;: vertex.z});
        var top = _.max(pair, &#039;y&#039;);
        var alreadyInList = _.filter(topVertices, {&#039;x&#039;: top.x, &#039;z&#039;: top.z}).length &gt; 0;
        alreadyInList = topVertices.indexOf(top) &gt; -1;
        // zweite Bedinggung wegen Genauigkeitsverlust
        if (!alreadyInList &amp;&amp; top.y &gt; 0)
          topVertices.push(top);
      });
      return topVertices;
    };

    /**
    * Get common vertices of two arrays
    */
    ProfileOutlineService.prototype.getCommonVertices = function(array1, array2){
      var result = [];
      var refArray = array1.length &gt; array2.length?array2:array1;
      var otherArray = refArray == array1?array2:array1;

      _.forEach(refArray, function(vertex, n){
        var filtered = _.filter(otherArray, {&#039;x&#039;: vertex.x, &#039;z&#039;: vertex.z});
        result = result.concat(filtered);
      });
      return result;
    },

    /**
    * create a mold by inverting the objects
    * @param {m3d.models.Profile} profile the profile to be inverted
    */
    ProfileOutlineService.prototype.invert = function(profile){
      $rootScope.$broadcast(&#039;outline:invert:start&#039;);
      profile.mesh.rotation.y = 0;
      // Quader für Gussform vorbereiten
      var boxBorderThickness = (profile.getDimensionY() * 1.1 - profile.getDimensionY()) * 2;
      var boxWidth = profile.getDimensionZ() + boxBorderThickness;
      var boxHeight = profile.getDimensionY() * 2 + boxBorderThickness;
      var boxDepth =  profile.getDimensionX() + boxBorderThickness;
      var boxGeometry = new THREE.BoxGeometry(boxDepth, boxHeight, boxWidth);
      boxGeometry.dynamic = true;
      // y-Position der unteren Vertices anpassen
      boxGeometry.vertices.forEach(function(vertex){
        if (vertex.y &lt; 0)
          vertex.y = -1 * boxBorderThickness;
      });
      boxGeometry.verticesNeedUpdate = true;        

      // Modell kopieren und Sockel erstellen
      var profileCopy = new Profile({
         profilePoints: profile.profilePoints
        ,mesh: profile.mesh.clone()
      });
      profileCopy.mesh.dynamic = true;

      // Sockel erstellen
      _.forEach(profileCopy.profilePoints, function(point, i){
        $rootScope.$broadcast(&#039;outline:invert:progress&#039;, {progress: i, total: profileCopy.profilePoints.length});
        var bottomIndex = ProfileUtil.getBottomIndex(i, profileCopy.mesh.geometry.vertices);
        profileCopy.mesh.geometry.vertices[bottomIndex].y = -1 * boxHeight;
      });   
      profileCopy.mesh.geometry.verticesNeedUpdate = true;
      profileCopy.mesh.geometry.mergeVertices();
      profileCopy.mesh.geometry.computeVertexNormals();

      // Gussform aus Quader konstruieren          
      var csgBox = new THREE.ThreeBSP(boxGeometry);
      var csgProfile = new THREE.ThreeBSP(profileCopy.mesh);
      var csgMold = csgBox.subtract(csgProfile);
      var geometry = csgMold.toGeometry();

      var material = new THREE.MeshPhongMaterial({color: 0x00ff00, dynamic: true });
      var mold = new THREE.Mesh(geometry, material);

      // Gussform um 180° drehen
      var moldRotation = new THREE.Matrix4().makeRotationX( Math.PI );
      mold.updateMatrix();
      mold.geometry.applyMatrix(mold.matrix);
      mold.geometry.applyMatrix(moldRotation);
      mold.matrix.identity();
      mold.name = profile.mesh.name + &#039;mold&#039;;
      $rootScope.$broadcast(&#039;outline:invert:end&#039;);
      return mold;
    };

    return [&#039;$log&#039;, &#039;$rootScope&#039;, ProfileOutlineService];
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
