<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - app\scripts\services\VRMLLoader.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>app\scripts\services\VRMLLoader.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">46.30</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">856</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">89.45</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.57</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* jshint ignore:start */

define([
	&#039;threejs&#039;
	],
	function(THREE){

	THREE.VRMLLoader = function () {};

	THREE.VRMLLoader.prototype = {

		constructor: THREE.VRMLLoader,

		// for IndexedFaceSet support
		isRecordingPoints: false,
		isRecordingFaces: false,
		points: [],
		indexes : [],

		// for Background support
		isRecordingAngles: false,
		isRecordingColors: false,
		angles: [],
		colors: [],

		recordingFieldname: null,

		load: function ( url, callback ) {

			var scope = this;
			var request = new XMLHttpRequest();

			request.addEventListener( &#039;load&#039;, function ( event ) {

				var object = scope.parse( event.target.responseText );

				scope.dispatchEvent( { type: &#039;load&#039;, content: object } );

				if ( callback ) callback( object );

			}, false );

			request.addEventListener( &#039;progress&#039;, function ( event ) {

				scope.dispatchEvent( { type: &#039;progress&#039;, loaded: event.loaded, total: event.total } );

			}, false );

			request.addEventListener( &#039;error&#039;, function () {

				scope.dispatchEvent( { type: &#039;error&#039;, message: &#039;Couldn\&#039;t load URL [&#039; + url + &#039;]&#039; } );

			}, false );

			request.open( &#039;GET&#039;, url, true );
			request.send( null );

		},

		loadLocal: function(file, callback){
			var scope = this;
			var r = new FileReader();
			r.onload = function(e){
				var contents = e.target.result;
				console.log(file.name);
				console.log(file.type);
				console.log(file.size);
				console.log(contents.substr(0,100));
				var content = scope.parse(contents);
				scope.dispatchEvent( { type: &#039;load&#039;, content: content, file: file } );
				if (callback) callback(content, file);
			};
			r.readAsBinaryString(file);
		},

		parse: function ( data ) {

			var parseV1 = function ( lines, scene ) {

				console.warn( &#039;VRML V1.0 not supported yet&#039; );

			};

			var parseV2 = function ( lines, scene ) {

				var defines = {};
				var float_pattern = /(\b|\-|\+)([\d\.e]+)/;
				var float3_pattern = /([\d\.\+\-e]+)\s+([\d\.\+\-e]+)\s+([\d\.\+\-e]+)/g;

				/**
				* Interpolates colors a and b following their relative distance
				* expressed by t.
				*
				* @param float a
				* @param float b
				* @param float t
				* @returns {Color}
				*/
				var interpolateColors = function(a, b, t) {
					var deltaR = a.r - b.r;
					var deltaG = a.g - b.g;
					var deltaB = a.b - b.b;

					var c = new THREE.Color();

					c.r = a.r - t * deltaR;
					c.g = a.g - t * deltaG;
					c.b = a.b - t * deltaB;

					return c;
				};

				/**
				 * Vertically paints the faces interpolating between the
				 * specified colors at the specified angels. This is used for the Background
				 * node, but could be applied to other nodes with multiple faces as well.
				 *
				 * When used with the Background node, default is directionIsDown is true if
				 * interpolating the skyColor down from the Zenith. When interpolationg up from
				 * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.
				 *
				 * The first angle is never specified, it is the Zenith (0 rad). Angles are specified
				 * in radians. The geometry is thought a sphere, but could be anything. The color interpolation
				 * is linear along the Y axis in any case.
				 *
				 * You must specify one more color than you have angles at the beginning of the colors array.
				 * This is the color of the Zenith (the top of the shape).
				 *
				 * @param geometry
				 * @param radius
				 * @param angles
				 * @param colors
				 * @param boolean directionIsDown Whether to work bottom up or top down.
				 */
				var paintFaces = function (geometry, radius, angles, colors, directionIsDown) {

					var f, n, p, vertexIndex, color;

					var direction = directionIsDown ? 1 : -1;

					var faceIndices = [ &#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039; ];

					var coord = [ ], aColor, bColor, t = 1, A = {}, B = {}, applyColor = false, colorIndex;

					for ( var k = 0; k &lt; angles.length; k++ ) {

						var vec = { };

						// push the vector at which the color changes
						vec.y = direction * ( Math.cos( angles[k] ) * radius);

						vec.x = direction * ( Math.sin( angles[k] ) * radius);

						coord.push( vec );

					}

					// painting the colors on the faces
					for ( var i = 0; i &lt; geometry.faces.length ; i++ ) {

						f  = geometry.faces[ i ];

						n = ( f instanceof THREE.Face3 ) ? 3 : 4;

						for ( var j = 0; j &lt; n; j++ ) {

							vertexIndex = f[ faceIndices[ j ] ];

							p = geometry.vertices[ vertexIndex ];

							for ( var index = 0; index &lt; colors.length; index++ ) {

								// linear interpolation between aColor and bColor, calculate proportion
								// A is previous point (angle)
								if ( index === 0 ) {

									A.x = 0;
									A.y = directionIsDown ? radius : -1 * radius;

								} else {

									A.x = coord[ index-1 ].x;
									A.y = coord[ index-1 ].y;

								}

								// B is current point (angle)
								B = coord[index];

								if ( undefined !== B ) {
									// p has to be between the points A and B which we interpolate
									applyColor = directionIsDown ? p.y &lt;= A.y &amp;&amp; p.y &gt; B.y : p.y &gt;= A.y &amp;&amp; p.y &lt; B.y;

									if (applyColor) {

										bColor = colors[ index + 1 ];

										aColor = colors[ index ];

										// below is simple linear interpolation
										t = Math.abs( p.y - A.y ) / ( A.y - B.y );

										// to make it faster, you can only calculate this if the y coord changes, the color is the same for points with the same y
										color = interpolateColors( aColor, bColor, t );

										f.vertexColors[ j ] = color;
									}

								} else if ( undefined === f.vertexColors[ j ] ) {
									colorIndex = directionIsDown ? colors.length -1 : 0;
									f.vertexColors[ j ] = colors[ colorIndex ];

								}
							}

						}

					}
				};

				var parseProperty = function (node, line) {

					var parts = [], part, property = {}, fieldName;

					/**
					 * Expression for matching relevant information, such as a name or value, but not the separators
					 * @type {RegExp}
					 */
					var regex = /[^\s,\[\]]+/g;

					var point, index, angles, colors;

					while (null != ( part = regex.exec(line) ) ) {
						parts.push(part[0]);
					}

					fieldName = parts[0];


					// trigger several recorders
					switch (fieldName) {
						case &#039;skyAngle&#039;:
						case &#039;groundAngle&#039;:
							this.recordingFieldname = fieldName;
							this.isRecordingAngles = true;
							this.angles = [];
							break;
						case &#039;skyColor&#039;:
						case &#039;groundColor&#039;:
							this.recordingFieldname = fieldName;
							this.isRecordingColors = true;
							this.colors = [];
							break;
						case &#039;point&#039;:
							this.recordingFieldname = fieldName;
							this.isRecordingPoints = true;
							this.points = [];
							break;
						case &#039;coordIndex&#039;:
							this.recordingFieldname = fieldName;
							this.isRecordingFaces = true;
							this.indexes = [];
							break;
					}

					if (this.isRecordingFaces) {

						// the parts hold the indexes as strings
						if (parts.length &gt; 0) {
							index = [];

							for (var ind = 0;ind &lt; parts.length; ind++) {

								// the part should either be positive integer or -1
								if (!/(-?\d+)/.test( parts[ind]) ) {
									continue;
								}

								// end of current face
								if (parts[ind] === &quot;-1&quot;) {
									if (index.length &gt; 0) {
									   this.indexes.push(index);
									}

									// start new one
									index = [];
								} else {
									index.push(parseInt( parts[ind]) );
								}
							}

						}

						// end
						if (/]/.exec(line)) {
							this.isRecordingFaces = false;
							node.coordIndex = this.indexes;
						}

					} else if (this.isRecordingPoints) {

						while ( null !== ( parts = float3_pattern.exec(line) ) ) {
							point = {
								x: parseFloat(parts[1]),
								y: parseFloat(parts[2]),
								z: parseFloat(parts[3])
							};

							this.points.push(point);
						}

						// end
						if ( /]/.exec(line) ) {
							this.isRecordingPoints = false;
							node.points = this.points;
						}

					} else if ( this.isRecordingAngles ) {

						// the parts hold the angles as strings
						if ( parts.length &gt; 0 ) {

							for ( var ind = 0;ind &lt; parts.length; ind++ ) {

								// the part should be a float
								if ( ! float_pattern.test( parts[ind] ) ) {
									continue;
								}

								this.angles.push( parseFloat( parts[ind] ) );
							}

						}

						// end
						if ( /]/.exec(line) ) {
							this.isRecordingAngles = false;
							node[this.recordingFieldname] = this.angles;
						}

					} else if (this.isRecordingColors) {

						while( null !== ( parts = float3_pattern.exec(line) ) ) {

							color = {
								r: parseFloat(parts[1]),
								g: parseFloat(parts[2]),
								b: parseFloat(parts[3])
							};

							this.colors.push(color);

						}

						// end
						if (/]/.exec(line)) {
							this.isRecordingColors = false;
							node[this.recordingFieldname] = this.colors;
						}

					} else if ( parts[parts.length -1] !== &#039;NULL&#039; &amp;&amp; fieldName !== &#039;children&#039;) {

						switch (fieldName) {

							case &#039;diffuseColor&#039;:
							case &#039;emissiveColor&#039;:
							case &#039;specularColor&#039;:
							case &#039;color&#039;:

								if (parts.length != 4) {
									console.warn(&#039;Invalid color format detected for &#039; + fieldName );
									break;
								}

								property = {
									r: parseFloat(parts[1]),
									g: parseFloat(parts[2]),
									b: parseFloat(parts[3])
								}

								break;

							case &#039;translation&#039;:
							case &#039;scale&#039;:
							case &#039;size&#039;:
								if (parts.length != 4) {
									console.warn(&#039;Invalid vector format detected for &#039; + fieldName);
									break;
								}

								property = {
									x: parseFloat(parts[1]),
									y: parseFloat(parts[2]),
									z: parseFloat(parts[3])
								}

								break;

							case &#039;radius&#039;:
							case &#039;topRadius&#039;:
							case &#039;bottomRadius&#039;:
							case &#039;height&#039;:
							case &#039;transparency&#039;:
							case &#039;shininess&#039;:
							case &#039;ambientIntensity&#039;:
								if (parts.length != 2) {
									console.warn(&#039;Invalid single float value specification detected for &#039; + fieldName);
									break;
								}

								property = parseFloat(parts[1]);

								break;

							case &#039;rotation&#039;:
								if (parts.length != 5) {
									console.warn(&#039;Invalid quaternion format detected for &#039; + fieldName);
									break;
								}

								property = {
									x: parseFloat(parts[1]),
									y: parseFloat(parts[2]),
									z: parseFloat(parts[3]),
									w: parseFloat(parts[4])
								}

								break;

							case &#039;ccw&#039;:
							case &#039;solid&#039;:
							case &#039;colorPerVertex&#039;:
							case &#039;convex&#039;:
								if (parts.length != 2) {
									console.warn(&#039;Invalid format detected for &#039; + fieldName);
									break;
								}

								property = parts[1] === &#039;TRUE&#039; ? true : false;

								break;
						}

						node[fieldName] = property;
					}

					return property;
				};

				var getTree = function ( lines ) {

					var tree = { &#039;string&#039;: &#039;Scene&#039;, children: [] };
					var current = tree;
					var matches;
					var specification;

					for ( var i = 0; i &lt; lines.length; i ++ ) {

						var comment = &#039;&#039;;

						var line = lines[ i ];

						// omit whitespace only lines
						if ( null !== ( result = /^\s+?$/g.exec( line ) ) ) {
							continue;
						}

						line = line.trim();

						// skip empty lines
						if (line === &#039;&#039;) {
							continue;
						}

						if ( /#/.exec( line ) ) {

							var parts = line.split(&#039;#&#039;);

							// discard everything after the #, it is a comment
							line = parts[0];

							// well, let&#039;s also keep the comment
							comment = parts[1];
						}

						if ( matches = /([^\s]*){1}\s?{/.exec( line ) ) { // first subpattern should match the Node name

							var block = { &#039;nodeType&#039; : matches[1], &#039;string&#039;: line, &#039;parent&#039;: current, &#039;children&#039;: [],&#039;comment&#039; : comment};
							current.children.push( block );
							current = block;

							if ( /}/.exec( line ) ) {
								// example: geometry Box { size 1 1 1 } # all on the same line
								specification = /{(.*)}/.exec( line )[ 1 ];

								// todo: remove once new parsing is complete?
								block.children.push( specification );

								parseProperty(current, specification);

								current = current.parent;

							}

						} else if ( /}/.exec( line ) ) {

							current = current.parent;

						} else if ( line !== &#039;&#039; ) {

							parseProperty(current, line);
							// todo: remove once new parsing is complete? we still do not parse geometry and appearance the new way
							current.children.push( line );

						}

					}

					return tree;
				}

				var parseNode = function ( data, parent ) {

					// console.log( data );

					if ( typeof data === &#039;string&#039; ) {

						if ( /USE/.exec( data ) ) {

							var defineKey = /USE\s+?(\w+)/.exec( data )[ 1 ];

							if (undefined == defines[defineKey]) {
								console.warn(defineKey + &#039; is not defined.&#039;);
							} else {

								if ( /appearance/.exec( data ) &amp;&amp; defineKey ) {

									parent.material = defines[ defineKey ].clone();

								} else if ( /geometry/.exec( data ) &amp;&amp; defineKey ) {

									parent.geometry = defines[ defineKey ].clone();

									// the solid property is not cloned with clone(), is only needed for VRML loading, so we need to transfer it
									if (undefined !== defines[ defineKey ].solid &amp;&amp; defines[ defineKey ].solid === false) {
										parent.geometry.solid = false;
										parent.material.side = THREE.DoubleSide;
									}

								} else if (defineKey){

									var object = defines[ defineKey ].clone();
									parent.add( object );

								}

							}

						}

						return;

					}

					var object = parent;

					if ( &#039;Transform&#039; === data.nodeType || &#039;Group&#039; === data.nodeType ) {

						object = new THREE.Object3D();

						if ( /DEF/.exec( data.string ) ) {
							object.name = /DEF\s+(\w+)/.exec( data.string )[ 1 ];
							defines[ object.name ] = object;
						}

						if ( undefined !== data[&#039;translation&#039;] ) {

							var t = data.translation;

							object.position.set(t.x, t.y, t.z);

						}

						if ( undefined !== data.rotation ) {

							var r = data.rotation;

							object.quaternion.setFromAxisAngle( new THREE.Vector3( r.x, r.y, r.z ), r.w );

						}

						if ( undefined !== data.scale ) {

							var s = data.scale;

							object.scale.set( s.x, s.y, s.z );

						}

						parent.add( object );

					} else if ( &#039;Shape&#039; === data.nodeType ) {

						object = new THREE.Mesh();

						if ( /DEF/.exec( data.string ) ) {

							object.name = /DEF (\w+)/.exec( data.string )[ 1 ];

							defines[ object.name ] = object;
						}

						parent.add( object );

					} else if ( &#039;Background&#039; === data.nodeType ) {

						var segments = 20;

						// sky (full sphere):

						var radius = 2e4;

						var skyGeometry = new THREE.SphereGeometry( radius, segments, segments );
						var skyMaterial = new THREE.MeshBasicMaterial( { fog: false, side: THREE.BackSide } );

						if ( data.skyColor.length &gt; 1 ) {

							paintFaces( skyGeometry, radius, data.skyAngle, data.skyColor, true );

							skyMaterial.vertexColors = THREE.VertexColors

						} else {

							var color = data.skyColor[ 0 ];
							skyMaterial.color.setRGB( color.r, color.b, color.g );

						}

						scene.add( new THREE.Mesh( skyGeometry, skyMaterial ) );

						// ground (half sphere):

						if ( data.groundColor !== undefined ) {

							radius = 1.2e4;

							var groundGeometry = new THREE.SphereGeometry( radius, segments, segments, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );
							var groundMaterial = new THREE.MeshBasicMaterial( { fog: false, side: THREE.BackSide, vertexColors: THREE.VertexColors } );

							paintFaces( groundGeometry, radius, data.groundAngle, data.groundColor, false );

							scene.add( new THREE.Mesh( groundGeometry, groundMaterial ) );

						}

					} else if ( /geometry/.exec( data.string ) ) {

						if ( &#039;Box&#039; === data.nodeType ) {

							var s = data.size;

							parent.geometry = new THREE.BoxGeometry( s.x, s.y, s.z );

						} else if ( &#039;Cylinder&#039; === data.nodeType ) {

							parent.geometry = new THREE.CylinderGeometry( data.radius, data.radius, data.height );

						} else if ( &#039;Cone&#039; === data.nodeType ) {

							parent.geometry = new THREE.CylinderGeometry( data.topRadius, data.bottomRadius, data.height );

						} else if ( &#039;Sphere&#039; === data.nodeType ) {

							parent.geometry = new THREE.SphereGeometry( data.radius );

						} else if ( &#039;IndexedFaceSet&#039; === data.nodeType ) {

							var geometry = new THREE.Geometry();

							var indexes;

							for ( var i = 0, j = data.children.length; i &lt; j; i++ ) {

								var child = data.children[ i ];

								var vec;

								if ( &#039;Coordinate&#039; === child.nodeType ) {

									for ( var k = 0, l = child.points.length; k &lt; l; k++ ) {

										var point = child.points[ k ];

										vec = new THREE.Vector3( point.x, point.y, point.z );

										geometry.vertices.push( vec );
									}

									break;
								}
							}

							var skip = 0;

							// read this: http://math.hws.edu/eck/cs424/notes2013/16_Threejs_Advanced.html
							for ( var i = 0, j = data.coordIndex.length; i &lt; j; i++ ) {

								indexes = data.coordIndex[i];

								// vrml support multipoint indexed face sets (more then 3 vertices). You must calculate the composing triangles here
								skip = 0;

								// todo: this is the time to check if the faces are ordered ccw or not (cw)

								// Face3 only works with triangles, but IndexedFaceSet allows shapes with more then three vertices, build them of triangles
								while ( indexes.length &gt;= 3 &amp;&amp; skip &lt; ( indexes.length -2 ) ) {

									var face = new THREE.Face3(
										indexes[0],
										indexes[skip + 1],
										indexes[skip + 2],
										null // normal, will be added later
										// todo: pass in the color, if a color index is present
									);

									skip++;

									geometry.faces.push( face );

								}


							}

							if ( false === data.solid ) {
								parent.material.side = THREE.DoubleSide;
							}

							// we need to store it on the geometry for use with defines
							geometry.solid = data.solid;

							geometry.computeFaceNormals();
							//geometry.computeVertexNormals(); // does not show
							geometry.computeBoundingSphere();

							// see if it&#039;s a define
							if ( /DEF/.exec( data.string ) ) {
								geometry.name = /DEF (\w+)/.exec( data.string )[ 1 ];
								defines[ geometry.name ] = geometry;
							}

							parent.geometry = geometry;
						}

						return;

					} else if ( /appearance/.exec( data.string ) ) {

						for ( var i = 0; i &lt; data.children.length; i ++ ) {

							var child = data.children[ i ];

							if ( &#039;Material&#039; === child.nodeType ) {
								var material = new THREE.MeshPhongMaterial();

								if ( undefined !== child.diffuseColor ) {

									var d = child.diffuseColor;

									material.color.setRGB( d.r, d.g, d.b );

								}

								if ( undefined !== child.emissiveColor ) {

									var e = child.emissiveColor;

									material.emissive.setRGB( e.r, e.g, e.b );

								}

								if ( undefined !== child.specularColor ) {

									var s = child.specularColor;

									material.specular.setRGB( s.r, s.g, s.b );

								}

								if ( undefined !== child.transparency ) {

									var t = child.transparency;

									// transparency is opposite of opacity
									material.opacity = Math.abs( 1 - t );

									material.transparent = true;

								}

								if ( /DEF/.exec( data.string ) ) {

									material.name = /DEF (\w+)/.exec( data.string )[ 1 ];

									defines[ material.name ] = material;

								}

								parent.material = material;

								// material found, stop looping
								break;
							}

						}

						return;

					}

					for ( var i = 0, l = data.children.length; i &lt; l; i ++ ) {

						var child = data.children[ i ];

						parseNode( data.children[ i ], object );

					}

				}

				parseNode( getTree( lines ), scene );

			};

			var scene = new THREE.Scene();

			var lines = data.split( &#039;\n&#039; );

			var header = lines.shift();

			if ( /V1.0/.exec( header ) ) {

				parseV1( lines, scene );

			} else if ( /V2.0/.exec( header ) ) {

				parseV2( lines, scene );

			}

			return scene;

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.VRMLLoader.prototype );
});
/* jshint ignore:end */</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
