<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - app\scripts\services\STLLoader.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>app\scripts\services\STLLoader.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">382</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">87.46</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.02</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* jshint ignore:start */

&#039;use strict&#039;;
define([
	&#039;threejs&#039;
	],
	function(THREE){
		THREE.STLLoader = function () {};

		THREE.STLLoader.prototype = {

			constructor: THREE.STLLoader

		};

		THREE.STLLoader.prototype.load = function ( url, callback ) {

			var scope = this;

			var xhr = new XMLHttpRequest();

			function onloaded( event ) {

				if ( event.target.status === 200 || event.target.status === 0 ) {

					var geometry = scope.parse( event.target.response || event.target.responseText );

					scope.dispatchEvent( { type: &#039;load&#039;, content: geometry } );

					if ( callback ) callback( geometry );

				} else {

					scope.dispatchEvent( { type: &#039;error&#039;, message: &#039;Couldn\&#039;t load URL [&#039; + url + &#039;]&#039;, response: event.target.statusText } );

				}

			}

			xhr.addEventListener( &#039;load&#039;, onloaded, false );

			xhr.addEventListener( &#039;progress&#039;, function ( event ) {

				scope.dispatchEvent( { type: &#039;progress&#039;, loaded: event.loaded, total: event.total } );

			}, false );

			xhr.addEventListener( &#039;error&#039;, function () {

				scope.dispatchEvent( { type: &#039;error&#039;, message: &#039;Couldn\&#039;t load URL [&#039; + url + &#039;]&#039; } );

			}, false );

			if ( xhr.overrideMimeType ) xhr.overrideMimeType( &#039;text/plain; charset=x-user-defined&#039; );
			xhr.open( &#039;GET&#039;, url, true );
			xhr.responseType = &#039;arraybuffer&#039;;
			xhr.send( null );

		};

		THREE.STLLoader.prototype.loadLocal = function(file, callback){
			var scope = this;
			var r = new FileReader();
			r.onload = function(e){
				var contents = e.target.result;
				console.log(file.name);
				console.log(file.type);
				console.log(file.size);
				console.log(contents.substr(0,100));
				var geometry =scope.parse(contents);
				scope.dispatchEvent( { type: &#039;load&#039;, content: geometry, file: file } );
				if (callback) callback(geometry, file);
			};
			r.readAsBinaryString(file);
		};

		THREE.STLLoader.prototype.parse = function ( data ) {


			var isBinary = function () {

				var expect, faceSize, nFaces, reader;
				reader = new DataView( binData );
				faceSize = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);
				nFaces = reader.getUint32(80,true);
				expect = 80 + (32 / 8) + (nFaces * faceSize);
				return expect === reader.byteLength;

			};

			var binData = this.ensureBinary( data );

			return isBinary()
				? this.parseBinary( binData )
				: this.parseASCII( this.ensureString( data ) );

		};

		THREE.STLLoader.prototype.parseBinary = function ( data ) {

			var reader = new DataView( data );
			var faces = reader.getUint32( 80, true );
			var dataOffset = 84;
			var faceLength = 12 * 4 + 2;

			var offset = 0;

			var geometry = new THREE.BufferGeometry();

			var vertices = new Float32Array( faces * 3 * 3 );
			var normals = new Float32Array( faces * 3 * 3 );

			for ( var face = 0; face &lt; faces; face ++ ) {

				var start = dataOffset + face * faceLength;

				for ( var i = 1; i &lt;= 3; i ++ ) {

					var vertexstart = start + i * 12;

					vertices[ offset     ] = reader.getFloat32( vertexstart, true );
					vertices[ offset + 1 ] = reader.getFloat32( vertexstart + 4, true );
					vertices[ offset + 2 ] = reader.getFloat32( vertexstart + 8, true );

					normals[ offset     ] = reader.getFloat32( start    , true );
					normals[ offset + 1 ] = reader.getFloat32( start + 4, true );
					normals[ offset + 2 ] = reader.getFloat32( start + 8, true );

					offset += 3;

				}

			}

			geometry.addAttribute( &#039;position&#039;, new THREE.BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( &#039;normal&#039;, new THREE.BufferAttribute( normals, 3 ) );

			return geometry;

		};

		THREE.STLLoader.prototype.parseASCII = function (data) {

			var geometry, length, normal, patternFace, patternNormal, patternVertex, result, text;
			geometry = new THREE.Geometry();
			patternFace = /facet([\s\S]*?)endfacet/g;

			while ( ( result = patternFace.exec( data ) ) !== null ) {

				text = result[0];
				patternNormal = /normal[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;

				while ( ( result = patternNormal.exec( text ) ) !== null ) {

					normal = new THREE.Vector3( parseFloat( result[ 1 ] ), parseFloat( result[ 3 ] ), parseFloat( result[ 5 ] ) );

				}

				patternVertex = /vertex[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;

				while ( ( result = patternVertex.exec( text ) ) !== null ) {

					geometry.vertices.push( new THREE.Vector3( parseFloat( result[ 1 ] ), parseFloat( result[ 3 ] ), parseFloat( result[ 5 ] ) ) );

				}

				length = geometry.vertices.length;

				geometry.faces.push( new THREE.Face3( length - 3, length - 2, length - 1, normal ) );

			}

			geometry.computeBoundingBox();
			geometry.computeBoundingSphere();

			return geometry;

		};

		THREE.STLLoader.prototype.ensureString = function (buf) {

			if (typeof buf !== &#039;string&#039;){
				var arrayBuffer = new Uint8Array(buf);
				var str = &#039;&#039;;
				for(var i = 0; i &lt; buf.byteLength; i++) {
					str += String.fromCharCode(arrayBuffer[i]); // implicitly assumes little-endian
				}
				return str;
			} else {
				return buf;
			}

		};

		THREE.STLLoader.prototype.ensureBinary = function (buf) {

			if (typeof buf === &#039;string&#039;){
				var arrayBuffer = new Uint8Array(buf.length);
				for(var i = 0; i &lt; buf.length; i++) {
					arrayBuffer[i] = buf.charCodeAt(i) &amp; 0xff; // implicitly assumes little-endian
				}
				return arrayBuffer.buffer || arrayBuffer;
			} else {
				return buf;
			}

		};

		THREE.EventDispatcher.prototype.apply( THREE.STLLoader.prototype );

		if ( typeof DataView === &#039;undefined&#039;){

			DataView = function(buffer, byteOffset, byteLength){

				this.buffer = buffer;
				this.byteOffset = byteOffset || 0;
				this.byteLength = byteLength || buffer.byteLength || buffer.length;
				this._isString = typeof buffer === &#039;string&#039;;

			}

			DataView.prototype = {

				_getCharCodes:function(buffer,start,length){
					start = start || 0;
					length = length || buffer.length;
					var end = start + length;
					var codes = [];
					for (var i = start; i &lt; end; i++) {
						codes.push(buffer.charCodeAt(i) &amp; 0xff);
					}
					return codes;
				},

				_getBytes: function (length, byteOffset, littleEndian) {

					var result;

					// Handle the lack of endianness
					if (littleEndian === undefined) {

						littleEndian = this._littleEndian;

					}

					// Handle the lack of byteOffset
					if (byteOffset === undefined) {

						byteOffset = this.byteOffset;

					} else {

						byteOffset = this.byteOffset + byteOffset;

					}

					if (length === undefined) {

						length = this.byteLength - byteOffset;

					}

					// Error Checking
					if (typeof byteOffset !== &#039;number&#039;) {

						throw new TypeError(&#039;DataView byteOffset is not a number&#039;);

					}

					if (length &lt; 0 || byteOffset + length &gt; this.byteLength) {

						throw new Error(&#039;DataView length or (byteOffset+length) value is out of bounds&#039;);

					}

					if (this.isString){

						result = this._getCharCodes(this.buffer, byteOffset, byteOffset + length);

					} else {

						result = this.buffer.slice(byteOffset, byteOffset + length);

					}

					if (!littleEndian &amp;&amp; length &gt; 1) {

						if (!(result instanceof Array)) {

							result = Array.prototype.slice.call(result);

						}

						result.reverse();
					}

					return result;

				},

				// Compatibility functions on a String Buffer

				getFloat64: function (byteOffset, littleEndian) {

					var b = this._getBytes(8, byteOffset, littleEndian),

						sign = 1 - (2 * (b[7] &gt;&gt; 7)),
						exponent = ((((b[7] &lt;&lt; 1) &amp; 0xff) &lt;&lt; 3) | (b[6] &gt;&gt; 4)) - ((1 &lt;&lt; 10) - 1),

					// Binary operators such as | and &lt;&lt; operate on 32 bit values, using + and Math.pow(2) instead
						mantissa = ((b[6] &amp; 0x0f) * Math.pow(2, 48)) + (b[5] * Math.pow(2, 40)) + (b[4] * Math.pow(2, 32)) +
									(b[3] * Math.pow(2, 24)) + (b[2] * Math.pow(2, 16)) + (b[1] * Math.pow(2, 8)) + b[0];

					if (exponent === 1024) {
						if (mantissa !== 0) {
							return NaN;
						} else {
							return sign * Infinity;
						}
					}

					if (exponent === -1023) { // Denormalized
						return sign * mantissa * Math.pow(2, -1022 - 52);
					}

					return sign * (1 + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);

				},

				getFloat32: function (byteOffset, littleEndian) {

					var b = this._getBytes(4, byteOffset, littleEndian),

						sign = 1 - (2 * (b[3] &gt;&gt; 7)),
						exponent = (((b[3] &lt;&lt; 1) &amp; 0xff) | (b[2] &gt;&gt; 7)) - 127,
						mantissa = ((b[2] &amp; 0x7f) &lt;&lt; 16) | (b[1] &lt;&lt; 8) | b[0];

					if (exponent === 128) {
						if (mantissa !== 0) {
							return NaN;
						} else {
							return sign * Infinity;
						}
					}

					if (exponent === -127) { // Denormalized
						return sign * mantissa * Math.pow(2, -126 - 23);
					}

					return sign * (1 + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);
				},

				getInt32: function (byteOffset, littleEndian) {
					var b = this._getBytes(4, byteOffset, littleEndian);
					return (b[3] &lt;&lt; 24) | (b[2] &lt;&lt; 16) | (b[1] &lt;&lt; 8) | b[0];
				},

				getUint32: function (byteOffset, littleEndian) {
					return this.getInt32(byteOffset, littleEndian) &gt;&gt;&gt; 0;
				},

				getInt16: function (byteOffset, littleEndian) {
					return (this.getUint16(byteOffset, littleEndian) &lt;&lt; 16) &gt;&gt; 16;
				},

				getUint16: function (byteOffset, littleEndian) {
					var b = this._getBytes(2, byteOffset, littleEndian);
					return (b[1] &lt;&lt; 8) | b[0];
				},

				getInt8: function (byteOffset) {
					return (this.getUint8(byteOffset) &lt;&lt; 24) &gt;&gt; 24;
				},

				getUint8: function (byteOffset) {
					return this._getBytes(1, byteOffset)[0];
				}

			 };

		}

	}
);

/* jshint ignore:end */</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
